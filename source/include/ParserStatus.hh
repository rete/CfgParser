  /// \file ParserStatus.hh
/*
 *
 * ParserStatus.hh header template generated by fclass
 * Creation date : mar. juin 4 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


#ifndef PARSERSTATUS_HH
#define PARSERSTATUS_HH

#include <iostream> 
#include <string> 
#include <cstdlib> 
#include <cmath> 
#include <vector> 


#define CFGPARSER_THROW_RESULT_IF( Status , Operator , Command )                                    \
	{ 																								 \
		StatusCode stat = Command;																	 \
		if( Status.fParserStatus Operator stat.fParserStatus ) { 								 \
																									 \
	        std::cerr << #Command << " throw " << stat.ToString() << std::endl;                   \
	        std::cerr << "    in function : " << __FUNCTION__ << std::endl;							 \
	        std::cerr << "    in file :     " << __FILE__ << " line#: " << __LINE__ << std::endl;    \
	        std::cerr << "    message :     " << stat.message << std::endl;                       \
	        throw CfgParserException( stat.message );											 \
		}																							 \
	}


#define CFGPARSER_THROW_RESULT( Status )                                    \
	{ 																								 \
	        std::cerr << "Status thrown : " << Status.ToString() << std::endl;                   \
	        std::cerr << "    in function : " << __FUNCTION__ << std::endl;							 \
	        std::cerr << "    in file :     " << __FILE__ << " line#: " << __LINE__ << std::endl;    \
	        std::cerr << "    message :     " << Status.message << std::endl;                       \
	        throw CfgParserException( Status.message );											 \
	}

#define CFGPARSER_CHECK_POINTER_AND_RETURN( Pointer )                       \
		{                                                                    \
			if( Pointer == 0 || Pointer == NULL )                            \
				return CFGPARSER_ERROR("Assertion pointer != 0 failed!");   \
		}

#define CFGPARSER_CHECK_POINTER_AND_THROW( Pointer )                                           \
		{                                                                                       \
			if( Pointer == 0 || Pointer == NULL ) {                                             \
				CFGPARSER_THROW_RESULT( CFGPARSER_ERROR("Assertion pointer != 0 failed!") );    \
			}                                                                                   \
		}

namespace cfgparser {


	enum ParserStatus {

		fParserSuccess,
		fParserError,
		fParserNoSectionError,
		fParserDuplicateSectionError,
		fParserNoOptionError,
		fParserInterpolationError,
		fParserInterpolationDepthError,
		fParserInterpolationMissingOptionError,
		fParserInterpolationSyntaxError,
		fParserMissingSectionNameError,
		fParserInvalidSectionKey,
		fParserValueError,
		fParserParsingError
	};



	class StatusCode {

		public:
			StatusCode() : fParserStatus(fParserSuccess) , message("") {}
			ParserStatus fParserStatus;
			std::string message;
			StatusCode& operator =(const StatusCode& statusCode);
			std::string ToString() const ;
	};

	bool operator != ( const StatusCode &sc1 , const StatusCode &sc2 );

	bool operator == ( const StatusCode &sc1 , const StatusCode &sc2 );


	StatusCode CFGPARSER_SUCCESS( const std::string &message = "" );

	StatusCode CFGPARSER_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_NO_SECTION_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_DUPLICATE_SECTION_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_NO_OPTION_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_VALUE_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_INTERPOLATION_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_INTERPOLATION_DEPTH_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_INTERPOLATION_MISSING_OPTION_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_INTERPOLATION_SYNTAX_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_INVALID_SECTION_KEY( const std::string &message = "" );

	StatusCode CFGPARSER_MISSING_SECTION_NAME_ERROR( const std::string &message = "" );

	StatusCode CFGPARSER_PARSING_ERROR( const std::string &message = "" );




	/*!
	 *
	 * @brief CfgParserExeption class.
	 * Responsible to throw exception for while using the CfgParser class
	 *
	 */
	class CfgParserException : public std::exception {

		protected :
			std::string error;

		public :
			/*!
			 *
			 * @brief Thrown constructor
			 *
			 */
			CfgParserException( const std::string &er ) throw()
				: error(er)  {};

			/*!
			 *
			 * @brief Default destructor
			 *
			 */
			virtual ~CfgParserException() throw() {};

			/*!
			 *
			 * @brief Return the exception message.
			 *
			 */
			virtual const char* what() const throw()
					{ return error.c_str(); }
	};


}  // namespace 

#endif  //  PARSERSTATUS_HH
