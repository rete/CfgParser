/// \file CfgParser.hh
 /*
 *
 * CfgParser.hh header template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */

#ifndef CFGPARSER_HH
#define CFGPARSER_HH

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <sstream>
#include <map>
#include <vector>
#include <algorithm>


// cfgparser includes
#include "Section.hh"
#include "ParserStatus.hh"
#include "StrOp.hh"
#include "RawCfgParser.hh"


namespace cfgparser {


	/**
	 * @brief  ChainSection class,
	 * this class is a helper class for CfgParser
	 * class while using interpolations.
	 *
	 * It aims to find a value in a given set of sections
	 * by looking for in each section with a specific
	 * order. First section appended, first section
	 * checked. This class is not really useful if
	 * used in an other context of CfgParser library.
	 */

	class ChainSection {

	public:

		/**
		 * @brief Constructor
		 */
		ChainSection();

		/**
		 * @brief Destructor
		 */
		~ChainSection();

		/**
		 * @brief Add a section to the section list
		 */
		void addSection( Section *sec )
		{
			_sectionCollection->push_back( sec );
		}

		/**
		 * @brief Returns a value by looking in the order where
		 * the sections have been added.
		 */
		std::string getValue( const std::string &option ) const;

		/**
		 * @brief Returns all the options of all sections
		 */
		StringCollection getOptions() const;

		/**
		 * @brief Returns true if one of the sections has the given option
		 */
		bool hasOption( const std::string &opt ) const;


	// private members
	private:
		SectionCollection *_sectionCollection;    ///< The sections in a specific order


	};

	/**
	 * @brief  CfgParser class,
	 * implements a new getValue() virtual method for strings
	 * that interpolate a specific string portion like %()s
	 * with a given set of options.
	 *
	 * Read in the same manner as the RawCfgParser class.
	 *
	 * Example:
	 *
	 *    [section]
	 *
	 *    option1 : 42
	 *    option2 : %(option1)s is the answer of everything
	 *
	 *
	 * Here, option2 will resolve in "42 is the answer of everything"
	 * To disable this feature and retrieve the raw value, use the
	 * boolean value raw = true.
	 */

	class CfgParser : public RawCfgParser {


	// public member functions
	public :

		/**
		 * @brief Default constructor
		 */
		CfgParser();

		/**
		 * @brief Get a value with a type T
		 */
		template<typename T>
		T getValue( const std::string& sectionName , const std::string &key , bool raw = false , Section *vars = nullptr ) const
		{
			std::string option = key;
			std::string value;
			Section *section = nullptr;

			if( this->hasSection( sectionName ) ) {
				CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , RawCfgParser::getSection( sectionName , section ) );
			}
			else {
				if( sectionName != DEFAULT_SECTION )
					throw CfgParserException( "No section error : Section '"+sectionName+"' not found" );
			}

			// look up in successive sections in that order : vars -> section -> default
			ChainSection *chainSection = new ChainSection();

			if( vars != nullptr )
				chainSection->addSection( vars );
			if( section != nullptr ) {
				chainSection->addSection( section );
			}
			if( !_defaultSection->isEmpty() )
				chainSection->addSection( _defaultSection );

			value = chainSection->getValue( option );

			if( !raw ) {
				CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->interpolate( value , chainSection , &value ) );
			}

			delete chainSection;
			T finalVal;
			cfgparser::convert<T>( value , finalVal );
			return std::move( finalVal );
		}

	// protected member functions
	protected:

		/**
		 * @brief  Interpolate a given string with a given set of sections (ChainSection).
		 * The final value is retrieved in the 'value' argument
		 */
		StatusCode interpolate( const std::string &str , const ChainSection *chainSection , std::string *value ) const;

	};


}  //  end namespace cfgparser


#endif  // CFGPARSER_HH
