  /// \file StrOp.cc
/*
 *
 * StrOp.cc cpp file template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


#include "StrOp.hh"



using namespace std ;


namespace cfgparser {


	void StrTrim( string *str ) {

		// count leading spaces
		int i = 0;

		while ( i < (int)str->length() && isspace((*str)[i]) ) ++i;

		// delete leading spaces
		if ( i > 0 ) str->erase(0, i);

		// last char position
		i = str->length();
		int j = i;
		while (i > 0 && isspace((*str)[i - 1])) --i;

		// delete trailing spaces
		if ( i < j ) str->erase( i, j );
	}

	void RStrTrim( std::string *str ) {

		int i = str->length();

		int j = i;
		while (i > 0 && isspace((*str)[i - 1])) --i;

		// delete trailing spaces
		if ( i < j ) str->erase( i, j );
	}


	void NormalizeName(string *str) {

		// trim spaces
		StrTrim(str);

		unsigned int i, j;
		i = 0;

		// shrink multi-spaces
		while ( i < str->length() ) {

			// if space
			if (isspace((*str)[i])) {

				// detect row of spaces
				j = i;
				while ( j + 1 < str->length() && isspace((*str)[j + 1]) )
					++j;

				// if more than one space in row
				if (i < j)
					str->erase(i, j);
				++i;
			}
			// lower case
			else (*str)[i] = tolower((*str)[i]);

			++i;
		}
	}


	std::vector<std::string> Split( const std::string &str , const char delimiter , int maxSplit ) {

		std::vector<std::string> vec;
		string s;

		for ( unsigned int i=0 ; i<str.size() ; i++ ) {

			if( vec.size() == maxSplit ) {
				vec.push_back( str.substr(i) );
				break;
			}

			if( str[i] != delimiter )
				s.push_back( str[i] ) ;
			else {
				vec.push_back( s );
				s = "";
			}
			if( i == str.size() - 1 )
				vec.push_back( s );
		}

		return vec;
	}

	string ToLower( const string &str ) {

		string s;
		for( unsigned int i=0 ; i<str.size() ; i++ )
			s.push_back( tolower( str.at(i) ) );
		return s;
	}

	string ToUpper( const string &str ) {

		string s;
		for( unsigned int i=0 ; i<str.size() ; i++ )
			s.push_back( toupper( str.at(i) ) );
		return s;
	}

	StatusCode GroupSectionName( const string &completeSectionLine , string &sectionName ) {

		// read the section name
		sectionName.clear();
		string sectionLine = completeSectionLine;
		StrTrim( &sectionLine );

		if( sectionLine.empty() )
			return CFGPARSER_ERROR("Section name is empty");

		if( sectionLine.at(0) != '[' )
			return CFGPARSER_PARSING_ERROR("Section header beginning should be a [ character");

		for( unsigned int i=1 ; i<sectionLine.size() ; i++ ) {

			if( sectionLine.at( i ) == ']' )
				break;

			if( i == sectionLine.size()-1 && sectionLine.at(i) != ']' )
				return CFGPARSER_PARSING_ERROR("No ] character detected for section header end");

			sectionName += sectionLine.at( i );
		}

		StrTrim( &sectionName );

		return CFGPARSER_SUCCESS();
	}


	StatusCode GroupOptionSeparatorAndValue( const string &parserLine , string &option , string &separator , string &value ) {

		string line = parserLine;
		StrTrim( &line );

		if( line.empty() )
			return CFGPARSER_ERROR( "Parser line is empty!" );

		option.clear();
		separator.clear();
		value.clear();

		for( unsigned int i=0 ; i<line.size() ; i++ ) {

			if( i == line.size()-1 )
				return CFGPARSER_PARSING_ERROR("No = or : separator found");

			if( line.at(i) == ':' || line.at(i) == '=' ) {

				if( option.empty() )
					CFGPARSER_PARSING_ERROR("No option specified in line : '"+ parserLine +"'");

				StrTrim( &option );
				separator = line.at(i);

				if( line.size() <= i+2 )
					return CFGPARSER_PARSING_ERROR("No value after key '"+ option +"'");

				value = line.substr( i+1 );
				StrTrim( &value );
				if( value.empty() )
					return CFGPARSER_PARSING_ERROR("No value after key '"+ option +"'");
				break;
			}
			option += line.at(i);
		}





		return CFGPARSER_SUCCESS();
	}


}  //  end namespace cfgparser

