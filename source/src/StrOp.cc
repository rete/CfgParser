  /// \file StrOp.cc
/*
 *
 * StrOp.cc cpp file template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


#include "StrOp.hh"



using namespace std ;


namespace cfgparser {


	void strTrim( string *str ) {

		// count leading spaces
		int i = 0;

		while ( i < (int)str->length() && isspace((*str)[i]) ) ++i;

		// delete leading spaces
		if ( i > 0 ) str->erase(0, i);

		// last char position
		i = str->length();
		int j = i;
		while (i > 0 && isspace((*str)[i - 1])) --i;

		// delete trailing spaces
		if ( i < j ) str->erase( i, j );
	}


	void rStrTrim( std::string *str ) {

		int i = str->length();

		int j = i;
		while (i > 0 && isspace((*str)[i - 1])) --i;

		// delete trailing spaces
		if ( i < j ) str->erase( i, j );
	}


	void normalizeName(string *str) {

		// trim spaces
		strTrim(str);

		unsigned int i, j;
		i = 0;

		// shrink multi-spaces
		while ( i < str->length() ) {

			// if space
			if (isspace((*str)[i])) {

				// detect row of spaces
				j = i;
				while ( j + 1 < str->length() && isspace((*str)[j + 1]) )
					++j;

				// if more than one space in row
				if (i < j)
					str->erase(i, j);
				++i;
			}
			// lower case
			else (*str)[i] = tolower((*str)[i]);

			++i;
		}
	}


	std::vector<std::string> split( const std::string &str , const char delimiter , int maxSplit ) {

		std::vector<std::string> vec;
		string s;

		for ( unsigned int i=0 ; i<str.size() ; i++ ) {

			if( vec.size() == maxSplit ) {
				vec.push_back( str.substr(i) );
				break;
			}

			if( str[i] != delimiter )
				s.push_back( str[i] ) ;
			else {
				vec.push_back( s );
				s = "";
			}
			if( i == str.size() - 1 )
				vec.push_back( s );
		}

		return vec;
	}


	string toLower( const string &str ) {

		string s;
		for( unsigned int i=0 ; i<str.size() ; i++ )
			s.push_back( tolower( str.at(i) ) );
		return std::move( s );
	}


	string toUpper( const string &str ) {

		string s;
		for( unsigned int i=0 ; i<str.size() ; i++ )
			s.push_back( toupper( str.at(i) ) );
		return s;
	}


	StatusCode groupSectionName( const string &completeSectionLine , string &sectionName ) {

		// read the section name
		sectionName.clear();
		string sectionLine = completeSectionLine;
		strTrim( &sectionLine );

		if( sectionLine.empty() )
			return CFGPARSER_ERROR("Section name is empty");

		if( sectionLine.at(0) != '[' )
			return CFGPARSER_PARSING_ERROR("Section header beginning should be a [ character");

		for( unsigned int i=1 ; i<sectionLine.size() ; i++ ) {

			if( sectionLine.at( i ) == ']' )
				break;

			if( i == sectionLine.size()-1 && sectionLine.at(i) != ']' )
				return CFGPARSER_PARSING_ERROR("No ] character detected for section header end");

			sectionName += sectionLine.at( i );
		}

		strTrim( &sectionName );

		return CFGPARSER_SUCCESS();
	}


	StatusCode groupOptionSeparatorAndValue( const string &parserLine , string &option , string &separator , string &value ) {

		string line = parserLine;
		strTrim( &line );

		if( line.empty() )
			return CFGPARSER_ERROR( "Parser line is empty!" );

		option.clear();
		separator.clear();
		value.clear();

		for( unsigned int i=0 ; i<line.size() ; i++ ) {

			if( i == line.size()-1 )
				return CFGPARSER_PARSING_ERROR("No = or : separator found");

			if( line.at(i) == ':' || line.at(i) == '=' ) {

				if( option.empty() )
					CFGPARSER_PARSING_ERROR("No option specified in line : '"+ parserLine +"'");

				strTrim( &option );
				separator = line.at(i);

				if( line.size() <= i+2 )
					return CFGPARSER_PARSING_ERROR("No value after key '"+ option +"'");

				value = line.substr( i+1 );
				strTrim( &value );
				if( value.empty() )
					return CFGPARSER_PARSING_ERROR("No value after key '"+ option +"'");
				break;
			}
			option += line.at(i);
		}
		return CFGPARSER_SUCCESS();
	}





	template<>
	void convert( const std::string &value , int &convertedVal ) {

		convertedVal = std::move( atoi( value.c_str() ) );
	}


	template<>
	void convert( const std::string &value , double &convertedVal ) {

		convertedVal = std::move( (double)atof( value.c_str() ) );
	}


	template<>
	void convert( const std::string &value , float &convertedVal ) {

		convertedVal = std::move( atof( value.c_str() ) );
	}


	template<>
	void convert( const std::string &value , bool &convertedVal ) {

		if( value == "true" || value == "1" || value == "on" || value == "yes" )
			convertedVal = true;
		else if ( value == "false" || value == "0" || value == "off" || value == "no" )
			convertedVal = false;
		else
			throw CfgParserException( "Value error : No known conversion from" + value + " to boolean type." );
	}


	template<>
	void convert( const std::string &val , std::vector<std::string> &convertedVal ) {

		convertedVal.clear();
		std::string s;
		char motif = ':';

		for ( unsigned int i=0 ; i<val.size() ; i++ ) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				convertedVal.push_back( s );
				s = "";
			}
			if( i == val.size() - 1 )
				convertedVal.push_back( s );
		}
	}

	/**
	 * @brief Converts a string into type vector<int>
	 */
	template<>
	void convert( const std::string &val , std::vector<int> &convertedVal ) {

		convertedVal.clear();
		std::string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				convertedVal.push_back( atoi( s.c_str() ) );
				s = "";
			}
			if( i == val.size() - 1 )
				convertedVal.push_back( atoi( s.c_str() ) );
		}
	}

	/**
	 * @brief Converts a string into type vector<double>
	 */
	template<>
	void convert( const std::string &val , std::vector<double> &convertedVal ) {

		convertedVal.clear();
		std::string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				convertedVal.push_back( atof( s.c_str() ) );
				s = "";
			}
			if( i == val.size() - 1 )
				convertedVal.push_back( atof( s.c_str() ) );
		}
	}

	/**
	 * @brief Converts a string into type T
	 */
	template<>
	void convert( const std::string &val , std::vector<float> &convertedVal ) {

		convertedVal.clear();
		std::string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				convertedVal.push_back( atof( s.c_str() ) );
				s = "";
			}
			if( i == val.size() - 1 )
				convertedVal.push_back( atof( s.c_str() ) );
		}
	}

	/**
	 * @brief Converts a string into type vector<bool>
	 */
	template<>
	void convert( const std::string &val , std::vector<bool> &convertedVal ) {

		convertedVal.clear();
		std::string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {

				if( s == "true" || s == "1" || s == "on" || s == "yes" )
					convertedVal.push_back( true );
				else if ( s == "false" || s == "0" || s == "off" || s == "no" )
					convertedVal.push_back( false );
				else
					throw CfgParserException("Value error : No known conversion from "+ val +" to boolean type.");
				s = "";
			}
			if( i == val.size() - 1 ) {

				if( s == "true" || s == "1" || s == "on" || s == "yes" )
					convertedVal.push_back( true );
				else if ( s == "false" || s == "0" || s == "off" || s == "no" )
					convertedVal.push_back( false );
				else
					throw CfgParserException("Value error : No known conversion from "+ val +" to boolean type.");
			}
		}
	}


	template<>
	std::string toString( const int &value )
	{
		std::stringstream ss;
		ss << value;
		return std::move( ss.str() );
	}


	template<>
	std::string toString( const float &value )
	{
		std::stringstream ss;
		ss << value;
		return std::move( ss.str() );
	}


	template<>
	std::string toString( const double &value )
	{
		std::stringstream ss;
		ss << value;
		return std::move( ss.str() );
	}


	template<>
	std::string toString( const bool &value )
	{
		std::stringstream ss;
		ss << value;
		return std::move( ss.str() );
	}


	template<>
	std::string toString( const std::vector<std::string> &value )
	{
		std::string ss;
		for( auto i=0 ; i<value.size() ; i++ ) {
			ss += value.at(i);
			if( i != value.size() - 1 )
				ss += ':';
		}

		return std::move( ss );
	}


	template<>
	std::string toString( const std::vector<int> &value )
	{
		std::stringstream ss;
		for( auto i=0 ; i<value.size() ; i++ ) {
			ss << value.at(i);
			if( i != value.size() - 1 )
				ss << ':';
		}
		return std::move( ss.str() );
	}


	template<>
	std::string toString( const std::vector<float> &value )
	{
		std::stringstream ss;
		for( auto i=0 ; i<value.size() ; i++ ) {
			ss << value.at(i);
			if( i != value.size() - 1 )
				ss << ':';
		}

		return std::move( ss.str() );
	}


	template<>
	std::string toString( const std::vector<double> &value )
	{
		std::stringstream ss;
		for( auto i=0 ; i<value.size() ; i++ ) {
			ss << value.at(i);
			if( i != value.size() - 1 )
				ss << ':';
		}

		return std::move( ss.str() );
	}


	template<>
	std::string toString( const std::vector<bool> &value )
	{
		std::stringstream ss;
		for( auto i=0 ; i<value.size() ; i++ ) {
			ss << value.at(i);
			if( i != value.size() - 1 )
				ss << ':';
		}

		return std::move( ss.str() );
	}




}  //  end namespace cfgparser

