  /// \file Section.cc
/*
 *
 * Section.cc source template generated by fclass
 * Creation date : mar. juin 4 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Section.hh"

using namespace std;

namespace cfgparser {


	Section::Section() {

		keyValueMap.clear();
		name = "";
	}

	Section::Section( const string &n ) {
		name = n;
		keyValueMap.clear();
	}


	Section::Section( Section const &section ) {

		name = section.name;
		keyValueMap = section.keyValueMap;
	}

	Section::~Section() {
		keyValueMap.clear();
	}


	StatusCode Section::SetValue( const string &key , const string &value ) {

		keyValueMap[ key ] = value;
		return CFGPARSER_SUCCESS();
	}


	bool Section::HasKey( const string &key ) {

		return (keyValueMap.find( key ) != keyValueMap.end() );
	}


	StatusCode Section::GetValue( const string &key , string *value ) {

		if( key.empty() )
			return CFGPARSER_INVALID_SECTION_KEY("Asked key is empty");

		if( keyValueMap.empty() )
			return CFGPARSER_INVALID_SECTION_KEY( string("Section is empty. Couldn't find key ") + key+ string("in section ") + name  );

		string k = key;
		NormalizeName(&k);

		KeyValueMap::iterator it = keyValueMap.find( k );
		if( it == keyValueMap.end() )
			return CFGPARSER_INVALID_SECTION_KEY( string("Couldn't find key ") + k + string("in section ") + name );

		*value = it->second;

		return CFGPARSER_SUCCESS();
	}

	StatusCode Section::GetValue( const string &key , int *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		*value = atoi( val.c_str() );
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const string &key , double *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		*value = atof( val.c_str() );
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const string &key , bool *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		if( val == "true" || val == "1" || val == "on" || val == "yes" )
			*value = true;
		else if ( val == "false" || val == "0" || val == "off" || val == "no" )
			*value = false;
		else return CFGPARSER_VALUE_ERROR("No known conversion from "+ val +" to boolean type.");
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const string &key , vector<string> *value ){

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( s );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( s );
		}
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const std::string &key , std::vector<double> *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val) );
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( atof( s.c_str() ) );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( atof( s.c_str() ) );
		}
		return CFGPARSER_SUCCESS();
	}





	StatusCode Section::GetValue( const std::string &key , std::vector<int> *value ) {

		string val;
		GetValue( key , &val);
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( atoi( s.c_str() ) );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( atoi( s.c_str() ) );
		}
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const std::string &key , std::vector<bool> *value ) {

		string val;
		GetValue( key , &val);
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				if( s == "true" || s == "1" || s == "on" || s == "yes" )
					value->push_back( true );
				else if ( s == "false" || s == "0" || s == "off" || s == "no" )
					value->push_back( false );
//				else return CFGPARSER_INVALID_VALUE();
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( atoi( s.c_str() ) );
		}
		return CFGPARSER_SUCCESS();
	}


	bool Section::IsEmpty() {
		return keyValueMap.empty();
	}


	StatusCode Section::Print() {

		if( this->IsEmpty() )
			return CFGPARSER_SUCCESS();

		cout << "[" << name << "]" << endl;
		KeyValueMap::iterator it;
		for(it=keyValueMap.begin() ; it!=keyValueMap.end() ; it++)
			cout << "  " << (*it).first << " = " << (*it).second << endl;

		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::Clear() {

		keyValueMap.clear();
		return CFGPARSER_SUCCESS();
	}

	Section& Section::operator +=( const Section& section ) {

		KeyValueMap::iterator it;
		for (it = section.GetKeyValueMap().begin() ; it != section.GetKeyValueMap().end() ; it++)
			this->SetValue( (*it).first , (*it).second );
		return *this;
	}


	Section operator+ ( const Section &section1 , const Section &section2 ) {

		Section section;
		section += section1;
		section += section2;
		section.SetName( section1.GetName() );
		return section;
	}

	StatusCode Section::RemoveKey( const std::string &key ) {

		if( key.empty() )
			return CFGPARSER_INVALID_SECTION_KEY("Assertion !key.empty() failed!");

		if( keyValueMap.find( key ) != keyValueMap.end() )
			keyValueMap.erase(key);
		else return CFGPARSER_INVALID_SECTION_KEY("Key '"+ key +"' not found!");

		return CFGPARSER_SUCCESS();
	}



}  // namespace 

