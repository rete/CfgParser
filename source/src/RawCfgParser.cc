  /// \file RawCfgParser.cc
/*
 *
 * RawCfgParser.cc source template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


#include "RawCfgParser.hh"

using namespace std;

namespace cfgparser {


	const string RawCfgParser::DEFAULT_SECTION = "DEFAULT";


//---------------------------------------------------------------------------------------------------------------

	/****************************
	 * Public member functions
	 ****************************/

	RawCfgParser::RawCfgParser( const OptionValueMap *optionValueMap , bool allowNoValue ) {

		defaultSection = new Section( DEFAULT_SECTION );

		if( optionValueMap != 0  && !optionValueMap->empty() ) {
			for( OptionValueMap::const_iterator it = optionValueMap->begin() ; it != optionValueMap->end() ; it++ ) {
				CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , defaultSection->SetValue( it->first , it->second ) );
			}
		}
		this->allowNoValue = allowNoValue;
		sections = new SectionCollection();
	}


	RawCfgParser::~RawCfgParser() {

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {
			if( sections->at(i) != 0 ) {
				delete sections->at(i);
				sections->at(i) = 0;
			}
		}
		sections->clear();
		delete sections;
		delete defaultSection;
	}


	StatusCode RawCfgParser::CreateSection( const std::string &secName ) {

		if( secName == DEFAULT_SECTION )
			return CFGPARSER_DUPLICATE_SECTION_ERROR("Default section can't be created by a user");

		if( !this->HasSection( secName ) ) {
			Section *section = new Section( secName );
			sections->push_back( section );
			return CFGPARSER_SUCCESS();
		}
		return CFGPARSER_DUPLICATE_SECTION_ERROR( "Section " + secName + " already exists!" );
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, std::string *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, int *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, double *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, bool *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, std::vector< std::string > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, std::vector< int > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, std::vector< double > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& sectionName , const std::string &option, std::vector< bool > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	bool RawCfgParser::RawCfgParser::HasOption( const std::string &sectionName , const std::string &option ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		return section->HasOption( option );
	}


	bool RawCfgParser::HasSection( const std::string &secName ) const {

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {
			if( sections->at(i)->GetName() == secName )
				return true;
		}
		return false;
	}


	bool RawCfgParser::HasSection( const Section *section ) const {

		for ( unsigned int i=0 ; i<sections->size() ; i++ ) {
			if( sections->at(i)->GetName() == section->GetName() )
				return true;
		}
		return false;
	}


	const Section *RawCfgParser::GetSection( const std::string &sectionName ) const {

		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !sectionName.empty() failed") );
		}

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {
			if( sections->at(i)->GetName() == sectionName ) {
				return sections->at(i);
			}
		}
		CFGPARSER_THROW_RESULT( CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" ) );
	}


	StatusCode RawCfgParser::Read( const std::string &fileName ) {

		if( fileName.empty() )
			return CFGPARSER_ERROR("Assertion !fileName.empty() failed");

		ifstream *cfgFile = new ifstream();
		cfgFile->open( fileName.c_str() );

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_Read( cfgFile ) );

		cfgFile->close();
		delete cfgFile;

		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Read( const std::vector< std::string > &fileNames ) {

		if( fileNames.empty() )
			return CFGPARSER_ERROR("Assertion !fileNames.empty() failed");

		for( unsigned int f=0 ; f<fileNames.size() ; f++ ) {

			ifstream *cfgFile = new ifstream();
			cfgFile->open( fileNames.at(f).c_str() );

			CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_Read( cfgFile ) );

			cfgFile->close();
			delete cfgFile;
		}

		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Read( std::ifstream& stream ) {

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_Read( &stream ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Read( std::ifstream* stream ) {

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_Read( stream ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::RemoveOption( const std::string &sectionName , const std::string &opt ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->RemoveOption( opt ) );
		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::RemoveSection( const std::string &sectionName ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		sections->erase( std::find( sections->begin() , sections->end() , section ) );
		delete section;
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const std::string &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const int &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const double &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const bool &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const std::vector< std::string > &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const std::vector< int > &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const std::vector< double > &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::SetValue( const std::string& sectionName , const std::string &option, const std::vector< bool > &value ) {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->SetValue( option , value ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Write( const std::string &fileName ) const {

		ofstream *cfgFile = new ofstream();
		cfgFile->open( fileName.c_str() );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->Write( cfgFile ) );
		cfgFile->close();
		delete cfgFile;
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Write( std::ofstream& stream ) const {

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->Write( &stream ) );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Write( std::ofstream* stream ) const {

		if( stream == 0 )
			return CFGPARSER_ERROR("Assertion stream != 0 failed");

		if( !stream->is_open() )
			return CFGPARSER_ERROR("Cfg file stream is not opened or doesn't exists!");

		if( sections->empty() )
			return CFGPARSER_ERROR("No section to write out!");

		time_t now = time( 0 );
		*stream << "######################################################" << endl;
		*stream << "# CfgParser libraries for configuration file parsing" << endl;
		*stream << "# @date : " << ctime( &now );
		*stream << "######################################################" << endl;
		*stream << endl;
		*stream << endl;
		*stream << endl;

		if( !defaultSection->IsEmpty() ) {

			*stream << "[DEFAULT]" << endl;
			*stream << endl;
			OptionValueMap optionValueMap = defaultSection->GetOptionValueMap();
			OptionValueMap::iterator it;
			for( it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				*stream << it->first << " = " << it->second << endl;
		}

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {

			*stream << "[" << sections->at(i)->GetName() << "]" << endl;
			*stream << endl;
			OptionValueMap optionValueMap = sections->at(i)->GetOptionValueMap();
			OptionValueMap::iterator it;
			for( it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				*stream << it->first << " = " << it->second << endl;
			*stream << endl;
			*stream << endl;
		}
		*stream << endl;

		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::Print() const {

		if( sections->empty() )
			return CFGPARSER_SUCCESS();

		if( !defaultSection->IsEmpty() ) {

			cout << "[DEFAULT]" << endl;
			cout << endl;
			OptionValueMap optionValueMap = defaultSection->GetOptionValueMap();
			OptionValueMap::iterator it;
			for( it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				cout << it->first << " = " << it->second << endl;
			cout << endl;
		}

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {

			cout << "[" << sections->at(i)->GetName() << "]" << endl;
			cout << endl;
			OptionValueMap optionValueMap = sections->at(i)->GetOptionValueMap();
			OptionValueMap::iterator it;
			for( it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				cout << it->first << " = " << it->second << endl;
			cout << endl;
		}
		return CFGPARSER_SUCCESS();
	}


	std::string RawCfgParser::OptionXForm( const std::string &optionStr ) const {

		return ToLower( optionStr );
	}


	const StringCollection RawCfgParser::GetOptions( const std::string &sectionName ) const {

		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed") );
		}

		Section *section = 0;
		StringCollection options;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		OptionValueMap optionValueMap = section->GetOptionValueMap();
		OptionValueMap::iterator it = optionValueMap.begin();
		for( ; it!=optionValueMap.end() ; it++ )
			options.push_back( it->first );

		return options;
	}


	const StringCollection RawCfgParser::GetValues( const std::string &sectionName ) const {

		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed") );
		}

		Section *section = 0;
		StringCollection values;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , section ) );
		OptionValueMap optionValueMap = section->GetOptionValueMap();
		OptionValueMap::iterator it = optionValueMap.begin();
		for( ; it!=optionValueMap.end() ; it++ )
			values.push_back( it->second );

		return values;
	}


	StatusCode RawCfgParser::Clear() {

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {
			CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , sections->at(i)->Clear() );
		}
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , defaultSection->Clear() );
		return CFGPARSER_SUCCESS();
	}


//---------------------------------------------------------------------------------------------------------------

	/****************************
	 * Private member functions
	 ****************************/

	StatusCode RawCfgParser::AddSection( Section *section ) {

		if( section == 0 )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion section != 0 failed");

		if( !this->HasSection( section ) ) {
			sections->push_back( section );
			return CFGPARSER_SUCCESS();
		}
		else return CFGPARSER_DUPLICATE_SECTION_ERROR( "Section " + section->GetName() + " already exists!" );
	}


	StatusCode RawCfgParser::_Read( std::ifstream* stream ) {

		if( stream == 0 )
			return CFGPARSER_ERROR("Assertion stream != 0 failed");

		if( !stream->is_open() )
			return CFGPARSER_ERROR("Cfg file stream is not opened or doesn't exists!");

		Section *currentSection = 0;
		string optionName = "";
		int lineNb = 0;

		while(true) {

			string line;
			getline( *stream , line );

			if( stream->eof() )
				break;

			lineNb++;

			if( line.empty() )
				continue;

			// check for comment line
			string tempLine = line;
			StrTrim( &tempLine );
			if( tempLine.empty() || tempLine.at(0) == ';' || tempLine.at(0) == '#' )
				continue;

			// Check for continuation line
			if( std::isspace( line.at(0)) ) {

				string value = line;
				StrTrim( &value );
				if( !value.empty() && currentSection != 0 ) {
					string val;
					CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , currentSection->GetValue( optionName , &val ) );
					CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , currentSection->SetValue( optionName , val + value ) );
				}
			}
			// Check for section header or option header in file
			else {

				string sectionName;
				// Is it a section header ?
				if( fParserSuccess == GroupSectionName( line , sectionName ).fParserStatus ) {

					if( this->HasSection( sectionName ) ) {

						CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( sectionName , currentSection) );
					}
					else if( sectionName == DEFAULT_SECTION ) {

						currentSection = defaultSection;
					}
					else {

						currentSection = new Section( sectionName );
						CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->AddSection( currentSection ) );

					}
					// A section can't start with continuation line
					optionName = "";
				}
				else if( currentSection == 0 ) {
					return CFGPARSER_MISSING_SECTION_NAME_ERROR("No section in cfg file!");
				}
				// Check for option line
				else {

					string separator;
					string value;
					StatusCode stat = GroupOptionSeparatorAndValue( line , optionName , separator , value );

					if( fParserSuccess == stat.fParserStatus ) {

						optionName = ToLower( optionName );

						if( !value.empty() ) {

							// ";" is a comment delimiter only if it follows
							// a spacing character
							size_t pos = value.find(';');

							if( pos != string::npos && isspace(value.at(pos-1)) ) {
								value = value.substr(0,pos);
							}

							StrTrim( &value );
							// Allows empty value
							if( value == "\"\"" )
								value = "";
							CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , currentSection->SetValue( optionName , value ) );

						}
						// Value-less option handling
						if( !allowNoValue && (value == "\"\"" || value.empty()) )
								return CFGPARSER_PARSING_ERROR("Missing value for option '"+ optionName +"' (allow no value set to true).\nTo allow empty value, switch on the 'allowNoValue' in constructor");

						CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , currentSection->SetValue( optionName , value ) );

					}
					else return stat;
				}
			}
		}

		return CFGPARSER_SUCCESS();

	}


	StatusCode RawCfgParser::GetSection( const std::string &sectionName , Section *&sec ) const {

		if( sectionName.empty() )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed");

		for( unsigned int i=0 ; i<sections->size() ; i++ ) {
			if( sections->at(i)->GetName() == sectionName ) {
				sec = sections->at(i);
				return CFGPARSER_SUCCESS();
			}
		}
		return CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" );
	}





}  // namespace 

