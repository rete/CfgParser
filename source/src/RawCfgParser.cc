  /// \file RawCfgParser.cc
/*
 *
 * RawCfgParser.cc source template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


#include "RawCfgParser.hh"

using namespace std;

namespace cfgparser {


	const string RawCfgParser::DEFAULT_SECTION = "DEFAULT";


//---------------------------------------------------------------------------------------------------------------

	/****************************
	 * Public member functions
	 ****************************/

	RawCfgParser::RawCfgParser( const OptionValueMap *optionValueMap , bool allowNoValue )
	{
		_defaultSection = new Section( DEFAULT_SECTION );

		if( optionValueMap != nullptr  && !optionValueMap->empty() ) {
			for( OptionValueMap::const_iterator it = optionValueMap->begin() ; it != optionValueMap->end() ; it++ ) {
				_defaultSection->setValue<string>( it->first , it->second );
			}
		}
		_allowNoValue = allowNoValue;
		_sections = new SectionCollection();
	}


	RawCfgParser::RawCfgParser( const RawCfgParser &parser )
	{
		_defaultSection = new Section( *(parser._defaultSection) );
		_sections = new SectionCollection();

		for( auto i=0 ; i<parser._sections->size() ; i++ ) {
			_sections->push_back( new Section( *(parser._sections->at(i)) ) );
		}
		_allowNoValue = parser._allowNoValue;
	}


	RawCfgParser::RawCfgParser( RawCfgParser &&parser )
	{
		_defaultSection = parser._defaultSection;
		_sections = parser._sections;
		parser._defaultSection = nullptr;
		parser._sections = nullptr;
		_allowNoValue = parser._allowNoValue;
	}


	RawCfgParser::~RawCfgParser()
	{
		for( unsigned int i=0 ; i<_sections->size() ; i++ ) {
			if( _sections->at(i) != nullptr ) {
				delete _sections->at(i);
				_sections->at(i) = nullptr;
			}
		}
		_sections->clear();
		delete _sections;
		delete _defaultSection;
		_sections = nullptr;
		_defaultSection = nullptr;
	}


	void RawCfgParser::createSection( const std::string &secName )
	{
		if( secName == DEFAULT_SECTION )
			throw CfgParserException( "Duplicated section : Default section can't be created by a user");

		if( !this->hasSection( secName ) ) {

			Section *section = new Section( secName );
			_sections->push_back( section );
		}
	}


	void RawCfgParser::addSection( Section *section ) {

		if( section == nullptr )
			return;

		if( !this->hasSection( section ) )
			_sections->push_back( section );
	}


	bool RawCfgParser::RawCfgParser::hasOption( const std::string &sectionName , const std::string &option ) const
	{
		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , section ) );
		return section->hasOption( option );
	}


	bool RawCfgParser::hasSection( const std::string &secName ) const
	{
		return ( std::find_if( _sections->begin()
							   ,_sections->begin()
							   ,[&] ( Section *s ) -> bool { return ( s->getName() == secName); } )
				!= _sections->end() );
	}


	bool RawCfgParser::hasSection( const Section *section ) const
	{
		return ( std::find_if( _sections->begin()
							   ,_sections->begin()
							   ,[&] ( Section *s ) -> bool { return ( s->getName() == section->getName() ); } )
				!= _sections->end() );
	}


	const Section *RawCfgParser::getSection( const std::string &sectionName ) const
	{
		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !sectionName.empty() failed") );
		}

		auto it = std::find_if( _sections->begin()
							  , _sections->end()
							  , [&] ( Section *s ) { return ( s->getName() == sectionName ); } );
		if( it != _sections->end() )
			return *it;

		CFGPARSER_THROW_RESULT( CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" ) );
	}


	void RawCfgParser::read( const std::string &fileName )
	{
		if( fileName.empty() )
			throw CfgParserException( "Error : fileName is an empty string");

		ifstream *cfgFile = new ifstream();
		cfgFile->open( fileName.c_str() );

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_read( cfgFile ) );

		cfgFile->close();
		delete cfgFile;
	}


	void RawCfgParser::read( const std::vector< std::string > &fileNames )
	{
		if( fileNames.empty() )
			throw CfgParserException( "Error : No file provided in vector");

		for( unsigned int f=0 ; f<fileNames.size() ; f++ ) {

			if( fileNames.at(f).empty() )
				throw CfgParserException( "Error : fileName is an empty string");

			ifstream *cfgFile = new ifstream();
			cfgFile->open( fileNames.at(f).c_str() );

			CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_read( cfgFile ) );

			cfgFile->close();
			delete cfgFile;
		}
	}


	void RawCfgParser::read( std::ifstream& stream )
	{
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_read( &stream ) );
	}


	void RawCfgParser::read( std::ifstream* stream )
	{
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_read( stream ) );
	}


	void RawCfgParser::removeOption( const std::string &sectionName , const std::string &opt )
	{
		Section *section = nullptr;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , section ) );
		section->removeOption( opt );
	}

	void RawCfgParser::removeSection( const std::string &sectionName ) {

		Section *section = nullptr;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , section ) );
		_sections->erase( std::find( _sections->begin() , _sections->end() , section ) );
		delete section;
	}


	void RawCfgParser::write( const std::string &fileName ) const
	{
		ofstream *cfgFile = new ofstream();
		cfgFile->open( fileName.c_str() );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_write( cfgFile ) );
		cfgFile->close();
		delete cfgFile;
	}


	void RawCfgParser::write( std::ofstream& stream ) const
	{
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_write( &stream ) );
	}


	void RawCfgParser::write( std::ofstream* stream ) const
	{
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->_write( stream ) );
	}


	StatusCode RawCfgParser::_write( std::ofstream* stream ) const
	{
		if( stream == nullptr )
			return CFGPARSER_ERROR("Assertion stream != 0 failed");

		if( !stream->is_open() )
			return CFGPARSER_ERROR("Cfg file stream is not opened or doesn't exists!");

		if( _sections->empty() )
			return CFGPARSER_ERROR("No section to write out!");

		time_t now = time( 0 );
		*stream << "######################################################" << endl;
		*stream << "# CfgParser libraries for configuration file parsing" << endl;
		*stream << "# @date : " << ctime( &now );
		*stream << "######################################################" << endl;
		*stream << endl;
		*stream << endl;
		*stream << endl;

		if( !_defaultSection->isEmpty() ) {

			*stream << "[DEFAULT]" << endl;
			*stream << endl;
			auto optionValueMap = _defaultSection->getOptionValueMap();
			for( auto it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				*stream << it->first << " = " << it->second << endl;
		}

		for( unsigned int i=0 ; i<_sections->size() ; i++ ) {

			*stream << "[" << _sections->at(i)->getName() << "]" << endl;
			*stream << endl;
			auto optionValueMap = _sections->at(i)->getOptionValueMap();

			for( auto it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				*stream << it->first << " = " << it->second << endl;
			*stream << endl;
			*stream << endl;
		}
		*stream << endl;

		return CFGPARSER_SUCCESS();
	}


	void RawCfgParser::print() const
	{

		if( _sections->empty() )
			return;

		if( !_defaultSection->isEmpty() ) {

			cout << "[DEFAULT]" << endl;
			cout << endl;
			auto optionValueMap = _defaultSection->getOptionValueMap();

			for( auto it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				cout << it->first << " = " << it->second << endl;
			cout << endl;
		}

		for( unsigned int i=0 ; i<_sections->size() ; i++ ) {

			cout << "[" << _sections->at(i)->getName() << "]" << endl;
			cout << endl;
			auto optionValueMap = _sections->at(i)->getOptionValueMap();

			for( auto it=optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
				cout << it->first << " = " << it->second << endl;
			cout << endl;
		}

	}


	std::string RawCfgParser::optionXForm( const std::string &optionStr ) const
	{
		return std::move( cfgparser::toLower( optionStr ) );
	}


	const StringCollection RawCfgParser::getOptions( const std::string &sectionName ) const
	{
		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed") );
		}

		Section *section = nullptr;
		StringCollection options;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , section ) );
		auto optionValueMap = section->getOptionValueMap();

		for( auto it = optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
			options.push_back( it->first );

		return std::move( options );
	}


	const StringCollection RawCfgParser::getValues( const std::string &sectionName ) const
	{
		if( sectionName.empty() ) {
			CFGPARSER_THROW_RESULT( CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed") );
		}

		Section *section = nullptr;
		StringCollection values;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , section ) );
		auto optionValueMap = section->getOptionValueMap();

		for( auto it = optionValueMap.begin() ; it!=optionValueMap.end() ; it++ )
			values.push_back( it->second );

		return std::move( values );
	}


	void RawCfgParser::clear()
	{
		for( unsigned int i=0 ; i<_sections->size() ; i++ )
			_sections->at(i)->clear();
		_defaultSection->clear();
	}


//---------------------------------------------------------------------------------------------------------------

	/****************************
	 * Private member functions
	 ****************************/

	StatusCode RawCfgParser::_read( std::ifstream* stream )
	{
		if( stream == nullptr )
			return CFGPARSER_ERROR("Assertion stream != 0 failed");

		if( !stream->is_open() )
			return CFGPARSER_ERROR("Cfg file stream is not opened or doesn't exists!");

		Section *currentSection = nullptr;
		string optionName = "";
		int lineNb = 0;

		while(true) {

			string line;
			getline( *stream , line );

			if( stream->eof() )
				break;

			lineNb++;

			if( line.empty() )
				continue;

			// check for comment line
			string tempLine = line;
			strTrim( &tempLine );
			if( tempLine.empty() || tempLine.at(0) == ';' || tempLine.at(0) == '#' )
				continue;

			// Check for continuation line
			if( std::isspace( line.at(0)) ) {

				string value = line;
				strTrim( &value );
				if( !value.empty() && currentSection != nullptr ) {
					string val;
					val = currentSection->getValue<string>( optionName );
					currentSection->setValue<string>( optionName , val + value );
				}
			}
			// Check for section header or option header in file
			else {

				string sectionName;
				// Is it a section header ?
				if( fParserSuccess == groupSectionName( line , sectionName )._parserStatus ) {

					if( this->hasSection( sectionName ) ) {

						CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->getSection( sectionName , currentSection) );
					}
					else if( sectionName == DEFAULT_SECTION ) {

						currentSection = _defaultSection;
					}
					else {

						currentSection = new Section( sectionName );
						this->addSection( currentSection );

					}
					// A section can't start with continuation line
					optionName = "";
				}
				else if( currentSection == nullptr ) {
					return CFGPARSER_MISSING_SECTION_NAME_ERROR("No section in cfg file!");
				}
				// Check for option line
				else {

					string separator;
					string value;
					StatusCode stat = cfgparser::groupOptionSeparatorAndValue( line , optionName , separator , value );

					if( fParserSuccess == stat._parserStatus ) {

						optionName = toLower( optionName );

						if( !value.empty() ) {

							// ";" is a comment delimiter only if it follows
							// a spacing character
							size_t pos = value.find(';');

							if( pos != string::npos && isspace(value.at(pos-1)) ) {
								value = value.substr(0,pos);
							}

							strTrim( &value );
							// Allows empty value
							if( value == "\"\"" )
								value = "";
							currentSection->setValue<string>( optionName , value );

						}
						// Value-less option handling
						if( !_allowNoValue && (value == "\"\"" || value.empty()) )
								return CFGPARSER_PARSING_ERROR("Missing value for option '"+ optionName +"' (allow no value set to true).\nTo allow empty value, switch on the 'allowNoValue' in constructor");

						currentSection->setValue<string>( optionName , value );

					}
					else return stat;
				}
			}
		}

		return CFGPARSER_SUCCESS();

	}


	StatusCode RawCfgParser::getSection( const std::string &sectionName , Section *sec ) const
	{
		if( sectionName.empty() )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed");

		for( unsigned int i=0 ; i<_sections->size() ; i++ ) {
			if( _sections->at(i)->getName() == sectionName ) {
				sec = _sections->at(i);
				return CFGPARSER_SUCCESS();
			}
		}
		return CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" );
	}

}  // namespace 

