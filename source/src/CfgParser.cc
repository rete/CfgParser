  /// \file CfgParser.cc
/*
 *
 * CfgParser.cc source file template generated by fclass
 * Creation date : jeu. juin 6 2013
 *
 * This file is part of CfgParser libraries.
 *
 * CfgParser is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CfgParser is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CfgParser.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author : Eté Rémi
 * @version 0.1.0 13/08/2013
 * @copyright 2013 Eté Rémi
 *
 */


using namespace std;


#include "CfgParser.hh"



namespace cfgparser {

//	const int CfgParser::MAX_INTERPOLATION_DEPTH = 10;




	StatusCode ChainSection::GetValue( const std::string &option , string *value ) const {

		for( unsigned int i=0 ; i<sectionCollection->size() ; i++ ) {

			StatusCode st = sectionCollection->at(i)->GetValue( option , value );
			if( st == CFGPARSER_INVALID_SECTION_KEY() )
				continue;
			else if( st == CFGPARSER_SUCCESS() )
				return st;
		}
		return CFGPARSER_INVALID_SECTION_KEY("Option '"+ option +"' not found in ChainSection");
	}


	StringCollection ChainSection::GetOptions() const {

		StringCollection result;
		StringCollection seen;

		for( unsigned int i=0 ; i<sectionCollection->size() ; i++ ) {

			OptionValueMap optValMap = sectionCollection->at(i)->GetOptionValueMap();

			for( OptionValueMap::iterator it = optValMap.begin() ; it != optValMap.end() ; it++ ) {

				if( std::find( seen.begin() , seen.end() , it->first ) == seen.end() ) {

					seen.push_back( it->first );
					result.push_back( it->first );
				}
			}
		}

		return result;
	}

	bool ChainSection::HasOption( const std::string &opt ) const {

		for( unsigned int i=0 ; i<sectionCollection->size() ; i++ ) {
			if( sectionCollection->at(i)->HasOption( opt ) )
				return true;
		}
		return false;
	}


//-------------------------------------------------------------------------------------------------------------------------------


	CfgParser::CfgParser() : RawCfgParser() {}


	StatusCode CfgParser::GetValue( const std::string& section , const std::string &opt , std::string *value , bool raw , Section *vars ) const {


		string option = opt;
		Section *sec = 0;

		if( this->HasSection( section ) ) {
			CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , RawCfgParser::GetSection( section , sec ) );
		}
		else {
			if( section != DEFAULT_SECTION )
				return CFGPARSER_NO_SECTION_ERROR("Section '"+section+"' not found");
		}

		// look up in successive sections in that order : vars -> section -> default
		ChainSection *chainSection = new ChainSection();

		if( vars != 0 )
			chainSection->AddSection( vars );
		if( sec != 0 ) {
			chainSection->AddSection( sec );
		}
		if( !defaultSection->IsEmpty() )
			chainSection->AddSection( defaultSection );

		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , chainSection->GetValue( option , value ) );

		if( raw ) {
			return CFGPARSER_SUCCESS();
			delete chainSection;
		}
		else {
			CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->Interpolate( *value , chainSection , value ) );
		}

		delete chainSection;
		return CFGPARSER_SUCCESS();
	}

	StatusCode CfgParser::Interpolate( const std::string &str , const ChainSection *chainSection , std::string *value ) const {

		string finalString = str;
		string tempString = str;

		size_t posOpen = 0;
		size_t posClose = 0;

		while(true) {

			posOpen = finalString.find( "%(" , posOpen );

			if( posOpen > finalString.size() )
				break;

			posClose = finalString.find( ")s" , posOpen );

			if( posClose > finalString.size() )
				return CFGPARSER_INTERPOLATION_SYNTAX_ERROR("Interpolation error in string '"+ str +"' : missing ')s'");

			string opt = finalString.substr( posOpen+2 , posClose - (posOpen+2) );

			if( chainSection->HasOption( RawCfgParser::OptionXForm( opt ) ) ) {
				string val;
				CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , chainSection->GetValue( opt , &val ) );
				finalString.replace( posOpen , (posClose-posOpen)+2 , val );
			}
			else {
				return CFGPARSER_INTERPOLATION_MISSING_OPTION_ERROR("Interpolation error in string '"+ str +"' , KeyError: '"+ opt +"'");
			}
		}

		*value = finalString;

		return CFGPARSER_SUCCESS();
	}


}  //  end namespace cfgparser
